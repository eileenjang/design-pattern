# 디자인 패턴 소개와 전략 패턴

- 디자인 패턴?

    - 소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 일반적인 해결책

- 누군가가 이미 여러분의 문제를 `해결`해 놓았습니다.

    - 1장에서는 다른 개발자가 여러분과 똑같은 문제를 경험하고 해결하면서 익혔던 지혜와 교훈들을 살펴보고, 그것들을 어떻게 활용할 수 있는지를 배웁니다.
    - 우선 디자인 패턴의 `활용 분야`와 디자인 패턴으로 얻을 수 있는 `장점`을 알아봅니다.
    - 핵심적인 `객체지향 디자인 원칙`을 살펴본 후, 한 가지 패턴을 정해 디자인 원칙이 어떤 식으로 작동하는지 알아보겠습니다.
    - 패턴을 잘 사용하려면, 패턴을 머릿속에 집어넣은 다음 -> 애플리케이션에 어떻게 적용할지를 파악해야 합니다.
    - 디자인 패턴은 코드가 아닌 `경험`을 재사용하는 것이니까요.

## 오리 시뮬레이션 게임, SimUDuck

- 조는 SimUDuck 이라는 오리 시뮬레이션을 만드는 회사에 다니고 있다.
- 게임에는 헤엄도 치고, 꽥꽥 소리도 내는 매우 다양한 오리가 등장한다.
- 시스템을 처음 디자인한 사람은, Duck이라는 슈퍼클래스를 만든 다음, 그 클래스를 확장해서 서로 다른 종류의 오리를 만들었다.

## 오리 시뮬레이션 게임 차별화하기

- 이제 오리들이 날아다닐 수 있도록 해야 한다는 임원진들의 결정이 내려졌다.
- `Duck` 클래스에 `fly()` 메소드만 추가하면 모든 오리가 그걸 상속받게 만들었다.

## 경고! 심각한 문제 발생

- 조는 Duck의 몇몇 서브클래스만 날아야 한다는 사실을 깜빡했다.
  - Duck이라는 슈퍼클래스에 fly() 메소드를 추가하면서 일부 서브클래스에 적합하지 않은 행동이 추가된 것.
- 그러나 유지보수 관점에서 상속은 좋은 방법이 아니였다.

## 상속을 생각하기

- fly() 메소드도 오버라이드 하면 되는 것?
- RubberDuck 이라는 날수도 소리낼 수도 없어야 하는 새로운 클래스 추가

## 인터페이스 설계하기

- `상속`은 옳은 방법이 아니였다.
- 상속을 계속 활용한다면 규격이 바뀔 때마다 프로그램에 추가했던 Duck의 서브클래스 fly() 와 quark() 메소드를 일일이 살펴보고 오버라이드 해야하기 때문.
- `fly()` 와 `quark()` 에 해당하는 각각의 인터페이스를 만들어서 서브클래스에서 구현할 수 있긴 하지만, `코드 중복`으로 관리가 힘들다.

## 해결 방법 고민하기

- 모든 서브클래스에 날거나 꽥꽥거리는 기능이 있어야 하는 건 아니므로 상속은 올바른 방법이 아니다.
- 서브클래스에서 Flyable, Quarkable을 구현해서 일부 문제를 해결할 수는 있지만, 코드 관리에 문제가 생긴다.
- 날 수 있는 오리들 중에서도 날아다니는 방식이 서로 다르다는 문제도 있다.
- 객체지향 소프트웨어 디자인 원칙을 적용해보자.

## 소프트웨어 개발 불편의 진리

- 아무리 디자인을 잘한 애플리케이션이라도 시간이 지남에 따라 변화하고 성장해야 한다.
- 그렇지 않으면 애플리케이션은 죽고 만다.

## 문제를 명확하게 파악하기

- 디자인 원칙
  - 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
  - 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 `캡슐화`한다.
  - 그러면, 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이면서 시스템의 `유연성`을 향상시킬 수 있다.
  - 즉, 코드의 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면 분리해야 한다.

## 바뀌는 부분과 그렇지 않은 부분 분리하기

- Duck 클래스와 완전히 별개로 2개의 클래스 집합을 만들어야 한다.
  - 나는 것과 관련된 부분, 꽥꽥거리는 것과 관련된 부분
- 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어넣는다.


## 오리의 행동을 디자인하는 방법

- 최대한 유연하게 만든다.
- MallardDuck 인스턴스를 새로 만들고 특정 형식의 나는 행동으로 초기화하는 방법
- Duck 클래스에 행동과 관련된 `setter` 메소드를 포함해서 프로그래밍 실행 중에도 행동을 바꿀 수 있게끔 하기
- 디자인 원칙
  - 구현보다는 `인터페이스`에 맞춰서 프로그래밍한다.
  - Duck의 행동은 별도의 클래스 안에 들어있게끔 하고, Duck 클래스에서는 그 행동을 구체적으로 구현할 필요가 없게 된다.









